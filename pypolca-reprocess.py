#!/usr/bin/env python3

"""
PYPOLCA-reprocess - A standalone command-line tool for fixing consensus sequences from VCF files.

This tool processes the intermediate VCF files generated by pypolca to fix errors in consensus sequences.

Usage:
    pypolca-reprocess.py -r reference.fasta -v variants.vcf -o corrected.fasta
    pypolca-reprocess.py --help
"""

import argparse
import shutil
import sys
from pathlib import Path
from typing import Optional, Tuple

from Bio import SeqIO
from Bio.Seq import Seq
from loguru import logger


def copy_file(src, dst):
    """Simple file copy function."""
    shutil.copy2(src, dst)


def fix_consensus_from_vcf(
    ref_contigs: Path,
    vcf: Path,
    out_fasta: Path,
    min_alt: int,
    min_ratio: float,
    homopolymers: Optional[int],
) -> Tuple[int, int]:
    """
    Fix errors in the consensus called in a VCF file by FreeBayes.

    Args:
        ref_contigs (Path): Path to the reference contigs in FASTA format.
        vcf (Path): Path to the VCF file containing variants.
        out_fasta (Path): Path to the output FASTA file.
        min_alt (int): Minimum number of alternative allele observations.
        min_ratio (float): Minimum ratio of alternative to reference alleles.
        homopolymers (Optional[int]): Only fix homopolymer changes of at least this length.

    Returns:
        total_subs (int): the total number of substitution changes made
        total_indels (int): the total number of indel changes made
    """
    if homopolymers is not None:
        logger.info(
            f"Homopolymer-only mode - ignoring all variants except for length changes in "
            f"â‰¥{homopolymers} bp homopolymers."
        )

    rseq = {}
    ctg, seq = "", ""

    # Read reference sequences
    with open(ref_contigs, "r") as file:
        for line in file:
            line = line.strip()
            if line.startswith(">"):
                if seq:
                    rseq[ctg] = seq
                ctg = line[1:].split()[0]
                seq = ""
            else:
                seq += line

    if seq:
        rseq[ctg] = seq

    # Initialize variables
    ctg = ""
    fixes = []
    originals = []
    offsets = []

    total_count = 0
    total_subs, total_indels = 0, 0

    # Read and process VCF file
    with open(vcf) as vcf_file:
        for line in vcf_file:
            line = line.strip()
            if line.startswith("#"):
                continue

            f = line.split()
            # Skip multiple allele cases
            if "," in f[4] or f[0] not in rseq:
                continue

            # Process new contig
            if f[0] != ctg:
                if fixes:
                    if ctg not in rseq:
                        raise Exception(
                            f"sequence {ctg} not found in the input fasta file"
                        )
                    oldseq = rseq[ctg]

                    # Apply fixes in reverse order to avoid position shifting
                    for i in range(len(fixes) - 1, -1, -1):
                        original_seq = oldseq[
                            offsets[i] - 1 : offsets[i] - 1 + len(originals[i])
                        ]
                        if (
                            any(c in "acgtnACGTN" for c in original_seq)
                            and not original_seq.upper() == originals[i].upper()
                        ):
                            logger.warning(
                                f"WARNING! Sequence does not match the original: "
                                f"{ctg} {original_seq} {originals[i]} {offsets[i]}"
                            )
                        else:
                            oldseq = (
                                oldseq[: offsets[i] - 1]
                                + fixes[i]
                                + oldseq[offsets[i] - 1 + len(originals[i]) :]
                            )

                    rseq[ctg] = oldseq

                fixes = []
                originals = []
                offsets = []
                ctg = f[0]

            # Check variant support
            ff = f[9].split(":")
            ref_count, alt_count = int(ff[3]), int(ff[5])
            ref_seq, alt_seq = f[3], f[4]
            if alt_count < min_alt or alt_count < min_ratio * ref_count:
                continue

            # Check homopolymer constraint
            if homopolymers is not None and not is_homopolymer_change(
                ref_seq, alt_seq, homopolymers
            ):
                continue

            # Add to fixes
            fixes.append(alt_seq)
            originals.append(ref_seq)
            offsets.append(int(f[1]))
            subs, indels = edit_distance(ref_seq, alt_seq)
            total_subs += subs
            total_indels += indels
            total_count += 1

    # Process final contig
    if total_count > 0:
        logger.info("POLCA has found variants. Fixing")
        oldseq = rseq[ctg]
        for i in range(len(fixes) - 1, -1, -1):
            if ctg not in rseq:
                raise Exception(f"sequence {ctg} not found in the input fasta file")
            original_seq = oldseq[offsets[i] - 1 : offsets[i] - 1 + len(originals[i])]
            if (
                any(c in "acgtnACGTN" for c in original_seq)
                and not original_seq.upper() == originals[i].upper()
            ):
                logger.warning(
                    f"WARNING! Sequence does not match the original: "
                    f"{ctg} {original_seq} {originals[i]} {offsets[i]}"
                )
            else:
                oldseq = (
                    oldseq[: offsets[i] - 1]
                    + fixes[i]
                    + oldseq[offsets[i] - 1 + len(originals[i]) :]
                )

        rseq[ctg] = oldseq

        # Write output
        records = []
        for contig, sequence in rseq.items():
            record = SeqIO.SeqRecord(seq=Seq(sequence), id=contig, description="")
            records.append(record)

        with open(out_fasta, "w") as output_file:
            SeqIO.write(records, output_file, "fasta")

    else:
        logger.warning("POLCA has found 0 variants.")
        logger.warning(
            f"The corrected FASTA {out_fasta} will be the same as the input FASTA {ref_contigs}."
        )
        copy_file(ref_contigs, out_fasta)

    return total_subs, total_indels


def edit_distance(s1, s2):
    """
    Calculate the global edit distance between two strings, providing separate counts for
    substitutions and indels.
    """
    s1, s2 = s1.upper(), s2.upper()
    dp = [[0 for n in range(len(s2) + 1)] for m in range(len(s1) + 1)]
    for i in range(len(s1) + 1):
        dp[i][0] = i
    for j in range(len(s2) + 1):
        dp[0][j] = j
    for i in range(1, len(s1) + 1):
        for j in range(1, len(s2) + 1):
            cost = 0 if s1[i - 1] == s2[j - 1] else 1
            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)
    subs, indels = 0, 0
    i, j = len(s1), len(s2)
    while i > 0 or j > 0:
        if (
            i > 0
            and j > 0
            and s1[i - 1] != s2[j - 1]
            and dp[i][j] == dp[i - 1][j - 1] + 1
        ):
            subs += 1
            i -= 1
            j -= 1
        elif i > 0 and dp[i][j] == dp[i - 1][j] + 1:
            indels += 1
            i -= 1
        elif j > 0 and dp[i][j] == dp[i][j - 1] + 1:
            indels += 1
            j -= 1
        else:
            i -= 1
            j -= 1
    return subs, indels


def is_homopolymer_change(ref_seq, alt_seq, homopolymer_length):
    """
    Check if the change between the ref and alt sequences is nothing but a homopolymer change.
    The homopolymer_length is the minimum length of consecutive identical bases (in the ref) 
    to be considered a homopolymer.
    """
    if ref_seq == alt_seq:
        return False

    ref = run_length_encoding(ref_seq)
    alt = run_length_encoding(alt_seq)

    # The sequence of bases (ignoring run lengths) must be identical.
    if [base for base, _ in ref] != [base for base, _ in alt]:
        return False

    # Each changed run must be long enough to be considered a homopolymer.
    for (_, ref_len), (_, alt_len) in zip(ref, alt):
        if ref_len != alt_len and ref_len < homopolymer_length:
            return False

    return True


def run_length_encoding(seq):
    """
    Encodes a sequence as a list of (base, length) tuples.
    Example: "AAACCGG" -> [('A', 3), ('C', 2), ('G', 2)]
    """
    if not seq:
        return []
    runs, prev, count = [], seq[0], 1
    for base in seq[1:]:
        if base == prev:
            count += 1
        else:
            runs.append((prev, count))
            prev, count = base, 1
    runs.append((prev, count))
    return runs


def main():
    """Main CLI entry point."""
    parser = argparse.ArgumentParser(
        description="Fix consensus sequences from VCF files using POLCA algorithm",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s -r reference.fasta -v variants.vcf -o corrected.fasta
  %(prog)s -r ref.fa -v vars.vcf -o out.fa --min-alt 3 --min-ratio 0.75
  %(prog)s -r ref.fa -v vars.vcf -o out.fa --homopolymers 5

Description:
  This tool processes VCF files to fix consensus sequences by applying variants
  that meet specified coverage and ratio thresholds. It can optionally focus
  only on homopolymer changes for more conservative corrections.
        """
    )
    
    # Required arguments
    parser.add_argument(
        "-r", "--reference",
        type=Path,
        required=True,
        help="Path to reference contigs in FASTA format"
    )
    
    parser.add_argument(
        "-v", "--vcf",
        type=Path,
        required=True,
        help="Path to VCF file containing variants"
    )
    
    parser.add_argument(
        "-o", "--output",
        type=Path,
        required=True,
        help="Path to output corrected FASTA file"
    )
    
    # Optional arguments
    parser.add_argument(
        "--min-alt",
        type=int,
        default=2,
        help="Minimum number of alternative allele observations (default: 2)"
    )
    
    parser.add_argument(
        "--min-ratio",
        type=float,
        default=0.5,
        help="Minimum ratio of alternative to reference alleles (default: 0.5)"
    )
    
    parser.add_argument(
        "--homopolymers",
        type=int,
        default=None,
        help="Only fix homopolymer changes of at least this length (optional)"
    )
    
    parser.add_argument(
        "--verbose", "-V",
        action="store_true",
        help="Enable verbose logging"
    )
    
    parser.add_argument(
        "--quiet", "-q",
        action="store_true",
        help="Suppress all output except errors"
    )
    
    parser.add_argument(
        "--version",
        action="version",
        version="POLCA v1.0.0"
    )
    
    args = parser.parse_args()
    
    # Configure logging
    if args.quiet:
        logger.remove()
        logger.add(sys.stderr, level="ERROR")
    elif args.verbose:
        logger.remove()
        logger.add(sys.stderr, level="DEBUG", 
                  format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | {message}")
    else:
        logger.remove()
        logger.add(sys.stderr, level="INFO", 
                  format="<level>{level: <8}</level> | {message}")
    
    # Validate input files
    if not args.reference.exists():
        logger.error(f"Reference file does not exist: {args.reference}")
        sys.exit(1)
    
    if not args.vcf.exists():
        logger.error(f"VCF file does not exist: {args.vcf}")
        sys.exit(1)
    
    # Validate parameters
    if args.min_alt < 1:
        logger.error("--min-alt must be at least 1")
        sys.exit(1)
    
    if args.min_ratio < 0:
        logger.error("--min-ratio must be non-negative")
        sys.exit(1)
    
    if args.homopolymers is not None and args.homopolymers < 1:
        logger.error("--homopolymers must be at least 1")
        sys.exit(1)
    
    # Create output directory if it doesn't exist
    args.output.parent.mkdir(parents=True, exist_ok=True)
    
    try:
        logger.info("Starting POLCA consensus correction")
        logger.info(f"Reference: {args.reference}")
        logger.info(f"VCF: {args.vcf}")
        logger.info(f"Output: {args.output}")
        logger.info(f"Parameters: min_alt={args.min_alt}, min_ratio={args.min_ratio}, homopolymers={args.homopolymers}")
        
        # Run the main function
        total_subs, total_indels = fix_consensus_from_vcf(
            ref_contigs=args.reference,
            vcf=args.vcf,
            out_fasta=args.output,
            min_alt=args.min_alt,
            min_ratio=args.min_ratio,
            homopolymers=args.homopolymers
        )
        
        logger.success("Consensus correction completed successfully!")
        logger.info(f"Total substitutions: {total_subs}")
        logger.info(f"Total indels: {total_indels}")
        logger.info(f"Output written to: {args.output}")
        
    except KeyboardInterrupt:
        logger.error("Process interrupted by user")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Error during consensus correction: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()

